<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
<<<<<<< HEAD
  <component name="ReplState" timestamp="1435270142133">{:repl-history {:ide [], :local [&quot;(in-ns \n  basicone.dsapoetra.zenleague.p25)&quot; &quot;()&quot; &quot;(count (lala 1\n             ))&quot; &quot;(count (lala 1))&quot; &quot;(+ 2 2\n   )&quot; &quot;(in-ns 'basicone.dsapoetra.zenleague.p25)&quot; &quot;(+ 2 2)&quot; &quot;(+ 5 5\n   )&quot; &quot;\n(in-ns 'basicone.dsapoetra.zenleague.p25)&quot; &quot;(explode-to-digits 100)&quot; &quot;(faktorial 5000)&quot; &quot;(faktorial 10000)&quot; &quot;(add 10)&quot; &quot;(add 10 11)&quot; &quot;(fak2 10 1)&quot; &quot;(faktorial 10)&quot; &quot;(fak2 10000 1)&quot; &quot;(fak2 10000)&quot; &quot;((fn [x] (* x x)) 5)&quot; &quot;(defn square [x] (* x x))&quot; &quot;((fn [x] (* x x)) 123)&quot; &quot;((fn [x] (* x x x)) 12)&quot; &quot;(#(* % % %) 12)&quot; &quot;(fn [] square)&quot; &quot;((fn [] square) 10)&quot; &quot;((fn [x] (* x x)) 10)&quot; &quot;(((fn [] square)) 10)&quot; &quot;((fn [x] (* x x 10)) 3)&quot; &quot;((fn [a b] (* a b)) 4 5)&quot; &quot;(let [[x &amp; xs] (range 10)] xs)&quot; &quot;(let [[x &amp; xs] (range 10)] x)&quot; &quot;(let [[a b c &amp; xs] (range 10)] [a b c xs])&quot; &quot;(let [[a b c &amp; jojon] (range 10)] [a b c jojon])&quot; &quot;(def m 10)&quot; &quot;(def sqr (fn [x] (* x x)))&quot; &quot;(sqr 23)&quot; &quot;(defn sqr [x] (* x x))&quot; &quot;(def mutlak (fn [x] (if (&gt;= x 0) x (- x))))&quot; &quot;(mutlak 10)&quot; &quot;(mutlak -10)&quot; &quot;(slurp \&quot;http://zeniusleague.com\&quot;)&quot; &quot;(take-rec 10 (range 100))&quot; &quot;(time (fibo 10))&quot; &quot;(time (fibo 20))&quot; &quot;(time (fibo 30))&quot; &quot;(time (fibo 40))&quot; &quot;(mfibo 40)&quot; &quot;(time (mfibo 40))&quot; &quot;(time (mfibo 400))&quot; &quot;(expt 10 999)&quot; &quot;(expt 10 9999)&quot; &quot;(time (expt 10 9999))&quot; &quot;(time (expt 10 999))&quot; &quot;(time (lfibo (expt 10 999)))&quot; &quot;(car/wcar (car/set :jojojo {:right \&quot;here\&quot;}))&quot; &quot;(car/wcar red-server\n          (car/set :jojojo {:right \&quot;here\&quot;}))&quot; &quot;(car/wcar red-server\n          (car/get :jojojo))&quot; &quot;(car/wcar red-server\n          (car/set :jojojo {:some \&quot;thing\&quot;}))&quot; &quot;(def m {})&quot; &quot;(assoc m :jojojo {:some \&quot;thing\&quot;})&quot; &quot;(def m (transient {}))&quot; &quot;(assoc! m :jojojo {:some \&quot;tng\&quot;})&quot; &quot;m &quot; &quot;(get m :jojojo)&quot; &quot;(assoc! m :whatever [12 4234 234 ])&quot; &quot;(get m :whatever)&quot; &quot;(java.util.UUID.)&quot; &quot;(def m (java.util.UUID.))&quot; &quot;(def m (new java.util.UUID))&quot; &quot;(time (rand-int (expt 10 9)))&quot; &quot;(Math/log10 10)&quot; &quot;(long (Math/pow 10 12))&quot; &quot;(long (Math/pow 10 15))&quot; &quot;(long (Math/pow 10 16))&quot; &quot;(long (Math/pow 10 17))&quot; &quot;(long (Math/pow 10 18))&quot; &quot;(long (Math/pow 10 20))&quot; &quot;(Math/log10 3)&quot; &quot;(str 1000)&quot; &quot;(str 1000 (apply str (reverse (str 1000))))&quot; &quot;(take 5 (cons 5 (map identity (range))))&quot; &quot;(long \&quot;123\&quot;)&quot; &quot;(.parseInt \&quot;123\&quot;)&quot; &quot;(parseInt \&quot;123\&quot;)&quot; &quot;(int \&quot;123\&quot;)&quot; &quot;(bigint \&quot;!23\&quot;)&quot; &quot;(bigint \&quot;123\&quot;)&quot; &quot;(take 10 (f 0))&quot; &quot;(f 1 1)&quot; &quot;(take 10 (f 1 1))&quot;], :remote []}}</component>
=======
  <component name="ReplState" timestamp="1435233272491">{:repl-history {:ide [], :local [&quot;\n(in-ns 'basicone.dsapoetra.zenleague.p25)&quot; &quot;(explode-to-digits 100)&quot; &quot;(range 3 1001 3)&quot; &quot;(kelipatan\n  )&quot; &quot;(kelipatan)&quot; &quot;(even? 4)&quot; &quot;(fibfourmillion 1000)&quot; &quot;(fibfourmillion 10)&quot; &quot;(time (fibfourmillion 1000))&quot; &quot;(time (fibfourmillion 10))&quot; &quot;(time (faktor-prima 600851475143))&quot; &quot;(largest-palindrome)&quot; &quot;(time (largest-palindrome))&quot; &quot;(time (small 10000\n             ))&quot; &quot;(time (small 10000))&quot; &quot;(time (small 1000))&quot; &quot;(time (small 100000))&quot; &quot;(small 10000N)&quot; &quot;(divisible 11)&quot; &quot;(defn small []\n  (loop [i 10000]\n    (when (&gt; i 2520)\n      (if (divisible i) (println i))\n      (recur (- i 1)))))&quot; &quot;(small)&quot; &quot;(defn small22 []\n  (loop [i 10000]\n    (when (&gt; i 2520)\n      (if (divisible i) (println i))\n      (recur (- i 1)))))\n&quot; &quot;(small 22)&quot; &quot;(small 10 )&quot; &quot;(small 10000)&quot; &quot;(small 100000)&quot; &quot;(small 1000000)&quot; &quot;(small 10000000)&quot; &quot;(small 100000000)&quot; &quot;(small 100000 10000)&quot; &quot;(small 1000000 100000)&quot; &quot;(small 10000000 100000)&quot; &quot;(small 100000000 1000000)&quot; &quot;(small 1000000000 100000000)&quot; &quot;(small 100000000 1000000000)&quot; &quot;(margin-natural 100)&quot; &quot;(last '(1 2 3 4))&quot; &quot;(last (first-n-prime 6))&quot; &quot;(last (first-n-prime 10001))&quot; &quot;(sqrt 25)&quot; &quot;(require '[clojure.math.numeric-tower :as math])&quot; &quot;(abs -10)&quot; &quot;(require '[clojure.contrib.math :as math])&quot; &quot;(pythagorean? 3 4 5)&quot; &quot;(pythagorean? 3 4 9)&quot; &quot;(thousand-pythagorean 1000\n                      )&quot; &quot;(defn euler-9b [sum]\n  (for [a (range 1 sum)\n        b (range a sum)\n        c [(- sum a b)]\n        :when (= (+ (* a a) (* b b)) (* c c))]\n    (bigint (* a b c))))&quot; &quot;(euler-9b 1000)&quot; &quot;(filter #(pythagorean? %1 %2 %3) '(1 2 3) '(2 3 4) '(3 4 5))&quot; &quot;(map #(filter pythagorean? %1 %2 %3) '( 1 2 3) '(2 3 4) '(4 5 6))&quot; &quot;(map #(pythagorean? %1 %2 %3) '( 1 2 3) '(2 3 4) '(4 5 6))&quot; &quot;(map #(pythagorean? %1 %2 %3) '(3) '(4) '(5))&quot; &quot;(thousand-pythagorean 1000)&quot; &quot;(apply max (first-n-prime 1001))&quot; &quot;(two-mi-prime 5000)&quot; &quot;(apply max (first-n-prime 5000))&quot; &quot;(apply max (first-n-prime 10000))&quot; &quot;(divisible 20)&quot; &quot;(apply max (first-n-prime 8000))&quot; &quot;(apply max (first-n-prime 20000))&quot; &quot;(apply max (first-n-prime 20000 10000))&quot; &quot;(apply max (max-n-prime 20000 10000))&quot; &quot;(apply max (max-n-prime 100000 90000))&quot; &quot;(apply max (max-n-prime 100000 99000))&quot; &quot;(in-ns 'basicone.dsapoetra.euler.p25\n       )&quot; &quot;(apply max (max-n-prime 100000 99990))&quot; &quot;(apply max (first-n-prime 10))&quot; &quot;(+ 2 2)&quot; &quot;(factors 90)&quot; &quot;(in-ns 'basicone.dsapoetra.euler.p25)&quot; &quot;(take-while #(&gt; 100 %) (fib 1 1))&quot; &quot;(two-mi-prime)&quot; &quot;(+ 5 5)&quot; &quot;(take 100 (iterate inc 1))&quot; &quot;(filter prime? (take 100 (iterate inc 1)))&quot; &quot;(filter prime? (take-while #(&gt; 1000 %) (iterate inc 1)))&quot; &quot;(reduce + (filter prime? (take-while #(&gt; 2000000 %) (iterate inc 1))))&quot; &quot;(reduce + (filter prime? (range 1 2000001)))&quot; &quot;(range 1 1 0)&quot; &quot;(range 1 9 0)&quot; &quot;(range 1 9 1)&quot; &quot;(triangle-nums)&quot; &quot;(euler-12-slow 500)&quot; &quot;(euler-12-fast 500)&quot; &quot;(prime-factors-of 28)&quot; &quot;(factors 28)&quot; &quot;(last (first-n-prime 100))&quot; &quot;(time (= (last ((fn first-n-prime [x]\n                  (take x (filter #(= 2 (reduce + (for [i (range 1 (inc %))](if (= 0 (mod % i)) 1 0)))) (range 1 Integer/MAX_VALUE)))) 100)) 541))&quot; &quot;(= (last ((fn first-n-prime [x]\n            (take x (filter #(= 2 (reduce + (for [i (range 1 (inc %))](if (= 0 (mod % i)) 1 0)))) (range 1 Integer/MAX_VALUE)))) 100)) 541)&quot; &quot;(&gt; \&quot;a\&quot; \&quot;b\&quot;)&quot; &quot;(&gt; a b)&quot; &quot;(sort \&quot;a\&quot; \&quot;b\&quot;)&quot; &quot;(compare \&quot;a\&quot; \&quot;b\&quot;)&quot; &quot;(sorted? '(\&quot;c\&quot; \&quot;a\&quot; \&quot;d\&quot;))&quot; &quot;(sorted? '(\&quot;c\&quot; \&quot;d\&quot;))&quot; &quot;(sorted-set \&quot;c\&quot; \&quot;a\&quot; \&quot;d\&quot;)&quot; &quot;(char 1)&quot; &quot;(char 2)&quot; &quot;(char 97)&quot; &quot;(char 120)&quot; &quot;(time (= (last ((fn [x](take x(filter #(= 2 (count (loop [x 1\n                                                          a %\n                                                          res '()]\n                                                     (if (&gt; x a)\n                                                       res\n                                                       (if (= 0(mod a x))\n                                                         (recur (inc x) a (conj res x))\n                                                         (recur (inc x) a res))\n                                                       )\n                                                     ))) (iterate inc 1)\n                                      )))\n                 100)) 541))&quot;], :remote []}}</component>
>>>>>>> origin/master
</project>